<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Frank's Redily</title><link rel=stylesheet href=/css/bulma.min.css><link rel=stylesheet href=/css/style.css></head><body class=terminal><section class=window><header class=window-header><div class="logo terminal-prompt"><a href=https://franknvc.github.io/ class=no-style>Frank's Redily</a>
<span style=color:blue>:~#</span>
<a href=https://franknvc.github.io/posts>posts</a><span style=color:#1a95e0>/</span>
<a href=https://franknvc.github.io/posts/web-development>web-development</a><span style=color:#1a95e0>/</span>
<a href=https://franknvc.github.io/posts/web-development/event-sourcing>event-sourcing</a><span style=color:#1a95e0>/</span></div><div class=window-controls><span class="control-item control-minimize">‒</span>
<span class="control-item control-maximize">□</span>
<span class="control-item control-close">˟</span></div></header><main class=window-content id=content><div class=container><div class=window-cursor><span class=i-cursor-indicator>></span><div class=terminal-nav><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"><li><a href=/about typeof="ListItem">/about</a></li><li><a href=/posts typeof="ListItem">/posts</a></li><li><a href=/projects typeof="ListItem">/projects</a></li><li><a href=/gallery typeof="ListItem">/photos</a></li><li><a href=/resume typeof="ListItem">/resumé</a></li></ul></nav></div><span class=i-cursor-underscore></span></div><div class=scrollable><h1>[Web Dev] Event Sourcing</h1>Apr. 23, 2021<br><br><blockquote><p><em>Capture all changes to an application state as a sequence of events.</em></p></blockquote><p>instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. this can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. it can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions</p><p>most applications work with data, and the typical approach is for the application to maintain the current state of the data by updating it as users work with it.</p><p>the crud approach has some limitation</p><ul><li>crud systems perform update operations directly against a data store, which can slow down performance and responsiveness</li><li>in a collaborative domain with many conccurent users, data update conflicts are more likely</li><li>unless there&rsquo;s an addition auditing mechanism that records the details of each operation in a separate log, history is lost</li></ul><p>the event sourcing pattern defines an approach to handling operations on data that&rsquo;s driven by a sequence of events, each of which is recorded in an append-only store. application code sends a series of events that imperatively describe each action that has occured on the data to the event store</p><ul><li>events are immutable, user interface, workflow, or process that initiated an event can continue, and tasks that handle the events can run in the background</li><li>events are simple object that describe some actions that occured, together with any associated data required</li><li>events typically have meaning for a domain expert</li><li>provides an audit trail that can be used to monitor action taken against a data store, regenerate the current state as materialized views or projections by replaying the events at any time, and assist in testing and debugging the system</li></ul><p>event sourcing is commonly combined with the CQRS pattern by performing the data management tasks in response to the events</p><h2 id=martin-fowler>Martin Fowler</h2><p>the fundamental idea of even sourcing is that of ensuring every change to the state of an application is captured in an event object, and that these event objects are themselves stored in the sequence they were applied for the same lifetime as the application state itself</p><p>the key to event sourcing is that we guarantee that all changes to the domain objects are initiated by the event objects. this leads to a number of facilities that can be built on top of the event log</p><ul><li>complete rebuild: re-running the events on an empty application</li><li>temporal query: we can determine the application state at any point in time</li><li>event replay: if we find a past event was incorrect, we can compute the consequences by reversing it and later events and replaying the new event and later events</li></ul><h3 id=application-state-storage>application state storage</h3><p>application states can be stored either in memory or on disk. since an application state is purely derivable from the event log, you can cache it anywhere you like.</p><h3 id=event-handler-logic>event handler logic</h3><p>the primary choices is whether to put the logic in transaction scripts or domain model. as usual transaction scripts are better for simple logic and a domain model is better when things get more complicated</p></div></div></main><footer class=bottom><small>Copyright 2021 Nguyen Viet Cuong</small></footer></section></body></html>